---
title: "p8105_hw6_qz2266"
author: "Qing Zhou"
date: "2022-11-30"
output: github_document
---

```{r packages}
library(tidyverse)
library(dplyr)
library(rvest)
library(purrr)
library(ggplot2)
library(modelr)
library(mgcv)
library(patchwork)
library(viridis)

knitr::opts_chunk$set(
  fig.width = 6,
  fig.asp = .6,
  out.width = "90%"
)
theme_set(theme_minimal() + theme(legend.position = "bottom"))
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d

```


### Problem 2

```{r read and tidy data}
# read data
homicide = 
  read.csv("https://raw.githubusercontent.com/washingtonpost/data-homicides/master/homicide-data.csv", na = c("","NA","Unknown")) %>%
  
# create a city_state variable, a binary solution variable and make sure victim_age is numeric
  mutate(
    city_state = str_c(city, state, sep = ", "),
    resolution = case_when(
           disposition == "Closed without arrest" ~ 0,
           disposition == "Open/No arrest"        ~ 0,
           disposition == "Closed by arrest"      ~ 1),
    victim_age = as.numeric(victim_age)
  ) %>% 
  
# Omit 4 cities
  filter(
    victim_race %in% c("White", "Black"),
    city_state != "Dallas, TX",
    city_state != "Phoenix, AZ",
    city_state != "Kansas City, MO",
    city_state != "Tulsa, AL") %>%
  filter(!is.na(victim_age)) %>%
  filter(!is.na(victim_sex)) %>%
  filter(!is.na(victim_race)) %>%
  filter(!is.na(resolution)) %>%
  filter(!is.na(city_state)) %>%
  select(city_state, resolution, victim_age, victim_sex, victim_race)
```
    
#### Run glm for the city of Baltimore, MD

```{r run glm logistic regression on Baltimore}
# baltimore df
baltimore_df =
  homicide %>% 
  filter(city_state == "Baltimore, MD")

# run glm
baltimore_glm = baltimore_df %>% 
  glm(resolution ~ victim_age + victim_sex + victim_race, 
      data = ., family = binomial(link = "logit")) %>%
  broom::tidy() %>% 
  mutate(
    OR = exp(estimate),
    lower_CI = exp(estimate - 1.96*std.error),
    upper_CI = exp(estimate + 1.96*std.error)
  ) %>% 
  select(term, OR, lower_CI, upper_CI) %>%
  filter(term == "victim_sexMale") %>%
  knitr::kable(digits = 3)
baltimore_glm
```

#### Run glm for each of the cities

```{r run glm for all cities}
city_df = 
  homicide %>% 
  nest(data = -city_state) %>% 
  mutate(
    raw_model = 
      map(data, ~glm(resolution ~ victim_age + victim_sex + victim_race, family = binomial(),data = .x)), 
    tidy_model = map(raw_model, broom::tidy)
  ) %>% 
  select(city_state, tidy_model) %>% 
  unnest(cols = tidy_model) %>%
  mutate(
     OR = exp(estimate),
     lower_CI = exp(estimate - 1.96*std.error),
     upper_CI = exp(estimate + 1.96*std.error)
  ) %>%
  filter(term == "victim_sexMale") %>%
  select(city_state, term, OR, lower_CI, upper_CI)
   
city_df
```

#### Create a plot that shows the estimated ORs and CIs for each city.

```{r  plot}
city_df %>% 
  mutate(city_state = fct_reorder(city_state, OR)) %>% 
  ggplot(aes(x = city_state, y = OR)) + 
  geom_point() + 
  geom_errorbar(aes(ymin = lower_CI, ymax = upper_CI)) + 
  labs(
    title = "Estimated ORs and CIs for Each City",
    x = "City, State",
    y = "Estimated Odds Ratio") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```


### Problem 3

```{r load and clean data}
birthweight = 
  read_csv("data/birthweight.csv", na = c("","NA","Unknown")) %>% 
  mutate( 
    babysex = as.factor(babysex),
    babysex = recode_factor(babysex,
                           "1" = "male",
                           "2" = "female"),
    frace = as.factor(frace),
    frace = recode_factor(frace,
                          "1" = "White",
                          "2" = "Black",
                          "3" = "Asian",
                          "4" = "Puerto Rican",
                          "8" = "Other"),
    malform = as.factor(malform),
    malform = recode_factor(malform,
                            "0" = "absent", 
                            "1" = "present"),
    mrace = as.factor(mrace),
    mrace = recode_factor(mrace,
                          "1" = "White",
                          "2" = "Black",
                          "3" = "Asian",
                      "4" = "Puerto Rican",
                      "8" = "Other")
    ) 
purrr::map(birthweight, ~ sum(is.na(.))) # check for missing data 
```

#### Propose a regression model for birthweight based on a hypothesized structure for the factors that underly birthweight.
```{r }
birthweight %>% 
  ggplot(aes(y = bwt, x = momage)) +
  geom_point() +
  geom_smooth()

birthweight %>% 
  ggplot(aes(y = bwt, x = ppwt, color = ppbmi)) +
  geom_point() +
  geom_smooth()

birthweight %>% 
  ggplot(aes(y = bwt, x = wtgain)) +
  geom_point() +
  geom_smooth()

birthweight %>% 
  ggplot(aes(y = bwt, x = smoken)) +
  geom_point() +
  geom_smooth()

```

```{r}
# correlation plot
library(corrplot)
bw_df = birthweight %>% 
  select(bwt, bhead, blength, delwt, fincome, gaweeks, menarche, mheight, parity, pnumlbw, pnumsga, ppwt, momage, ppbmi, wtgain, smoken)

corrplot(cor(bw_df), type = "upper", diag = FALSE)
```

```{r model building}
# use F-statistic for globally testing if ANY of the independent variables is related to the outcome.
bw_model_1 = birthweight %>% 
  lm(bwt ~ momage + ppbmi + wtgain + smoken, data = .) 
summary(bw_model_1)
bw_model_1 %>% 
  broom::tidy() %>% 
  knitr::kable(digit = 3)
```

To build a valid model,  bwt was selected as the outcome. My research question is whether Mom's status is related to the birth weight of their babies. So here I chose 

To verify 
Since the P value for the F-test of overall significance test is <2.2e-16, less than the significance level, we reject the null-hypothesis and conclude that this model provides a better fit than the intercept-only model, aka AT LEAST 1 independent variable is related to the outcome.

Moreover, the adjusted R-squared value is 0.1067, suggesting this regression model accounts for 11% of the variance.

####  Model diagnositcs: plots for residuals normality and for model residuals against fitted values

```{r plotting residuals normality}
# check the distribution of residuals
birthweight %>% 
  add_residuals(bw_model_1) %>%
      ggplot(aes(x = resid)) + geom_density()
```

```{r QQ_plot}
plot(bw_model_1, which = 2)
```

As the first step of model diagnostic, I checked if the residual is normally distributed. 

In the distribution plot, residuals follow a normal distribution centered on 0. In QQ plot, we can see a straight line with some outliers but the extent of outliers is acceptable. Thus, based on these two plots, we concluded the basic assumption of residual normality is satisfied in this model.

```{r plotting residuals against fitted values}
birthweight %>% 
  add_residuals(bw_model_1) %>%
    add_predictions(bw_model_1) %>% 
      ggplot(aes(x = pred, y = resid)) + 
      geom_point() +
      geom_smooth(se = F, color = "red", method = "lm") +
      labs(
      title = "Residuals vs. Fitted",
      x = "Fitted values",
      y = "Residuals"
      ) +
      theme(plot.title = element_text(hjust = 0.5))
```

Secondly, I checked residuals vs fitted values. This plot is used to detect unequal error variance (heteroscedasticity) and outliers.

From the plot we can see residuals values are symmetrically distributed and bounce around 0, which is their expected value. Residuals form a horizontal (linear) ‘band’ around zero. Therefore, from their random pattern, we concluded that the residuals have constant variance. Moreover, the plot shows a couple of ‘unusual’ values stand out from the random pattern, suggesting a few potential outliers.

#### Two alternative models

```{r alternative_models}
bw_model_2 =
  lm(bwt ~ blength + gaweeks, data = birthweight)
bw_model_2 %>% 
  broom::tidy() %>%
  knitr::kable(digit = 3)
plot(bw_model_2, which = 1)

bw_model_3 = 
  lm(bwt ~ bhead + blength + babysex + bhead*blength + blength*babysex + bhead*babysex + bhead*blength*babysex, data = birthweight)
bw_model_3 %>% 
  broom::tidy() %>%
  knitr::kable(digit = 3)
plot(bw_model_3, which = 1)
```

#### Cross validation of these three models


